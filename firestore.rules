rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper: Check if user is part of a couple
    function isPartnerInCouple(coupleId) {
      return isAuthenticated() &&
        request.auth.uid in get(/databases/$(database)/documents/couples/$(coupleId)).data.partnerIds;
    }

    // Helper: Get the other partner's ID
    function getPartnerId(coupleData) {
      return coupleData.partnerIds[0] == request.auth.uid
        ? coupleData.partnerIds[1]
        : coupleData.partnerIds[0];
    }

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Any authenticated user can read user documents (needed for partner info)
      allow read: if isAuthenticated();

      // Users can create their own document
      // Allow minimal doc (empty displayName/initial) for anonymous auth bootstrap
      allow create: if isAuthenticated()
        && request.auth.uid == userId
        && request.resource.data.keys().hasAll(['displayName', 'initial', 'activeCoupleId', 'createdAt'])
        && request.resource.data.displayName is string
        && request.resource.data.initial is string;

      // Users can update their own document (including activeCoupleId)
      allow update: if isAuthenticated() && request.auth.uid == userId;
    }

    // ============================================
    // COUPLES COLLECTION
    // ============================================
    match /couples/{coupleId} {
      // Anyone authenticated can read couples (needed for join flow validation)
      // This is acceptable for "known players" trusted user base
      allow read: if isAuthenticated();

      // Anyone authenticated can create a couple (as first partner)
      allow create: if isAuthenticated()
        && request.resource.data.partnerIds.size() == 1
        && request.resource.data.partnerIds[0] == request.auth.uid
        && request.resource.data.status == 'pending'
        && request.resource.data.keys().hasAll(['partnerIds', 'status', 'inviteCode', 'collectiveCupLevel', 'pointsPerAcknowledgment', 'createdAt', 'lastActivityAt']);

      // Partners can update couple (for joining, activity updates)
      // Simplified: any authenticated user can update if couple has <2 partners (joining)
      // or if they're already a partner (normal updates)
      allow update: if isAuthenticated()
        && (
          request.auth.uid in resource.data.partnerIds
          || resource.data.partnerIds.size() < 2
        );

      // ----------------------------------------
      // PLAYERS SUBCOLLECTION
      // ----------------------------------------
      match /players/{playerId} {
        // Anyone authenticated can read players (needed after join before listener updates)
        allow read: if isAuthenticated();

        // Users can create their own player document (for joining a couple)
        allow create: if isAuthenticated()
          && playerId == request.auth.uid
          && request.resource.data.keys().hasAll(['cupLevel', 'gemCount', 'joinedAt'])
          && request.resource.data.cupLevel == 0
          && request.resource.data.gemCount == 0;

        // Partners can update player documents (for gem/cup updates)
        allow update: if isPartnerInCouple(coupleId);
      }

      // ----------------------------------------
      // ATTEMPTS SUBCOLLECTION
      // ----------------------------------------
      match /attempts/{attemptId} {
        // Partners can read all attempts
        allow read: if isPartnerInCouple(coupleId);

        // Partners can create attempts (for their partner, not themselves)
        allow create: if isPartnerInCouple(coupleId)
          && request.resource.data.byPlayerId == request.auth.uid
          && request.resource.data.forPlayerId != request.auth.uid
          && request.resource.data.acknowledged == false
          && request.resource.data.keys().hasAll(['byPlayerId', 'forPlayerId', 'action', 'createdAt', 'acknowledged']);

        // Only recipient can acknowledge (update acknowledged field)
        allow update: if isPartnerInCouple(coupleId)
          && resource.data.forPlayerId == request.auth.uid
          && resource.data.acknowledged == false
          && request.resource.data.acknowledged == true;
      }

      // ----------------------------------------
      // REQUESTS SUBCOLLECTION
      // ----------------------------------------
      match /requests/{requestId} {
        // Partners can read all requests
        allow read: if isPartnerInCouple(coupleId);

        // Partners can create requests
        allow create: if isPartnerInCouple(coupleId)
          && request.resource.data.byPlayerId == request.auth.uid
          && request.resource.data.status == 'active';

        // Partners can update requests (cancel own, mark fulfilled)
        allow update: if isPartnerInCouple(coupleId);
      }

      // ----------------------------------------
      // SUGGESTIONS SUBCOLLECTION
      // ----------------------------------------
      match /suggestions/{suggestionId} {
        allow read: if isPartnerInCouple(coupleId);
        allow create: if isPartnerInCouple(coupleId)
          && request.resource.data.createdByPlayerId == request.auth.uid;
        allow update, delete: if isPartnerInCouple(coupleId);
      }
    }

    // ============================================
    // INVITE CODES COLLECTION
    // ============================================
    match /inviteCodes/{inviteCode} {
      // Anyone authenticated can read (to validate codes)
      allow read: if isAuthenticated();

      // Anyone authenticated can create invite codes
      allow create: if isAuthenticated()
        && request.resource.data.creatorId == request.auth.uid
        && request.resource.data.status == 'active';

      // Anyone authenticated can update (to mark as used when joining)
      allow update: if isAuthenticated()
        && resource.data.status == 'active'
        && request.resource.data.status == 'used';
    }
  }
}
