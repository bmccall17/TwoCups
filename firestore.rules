rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper: Check if user is authenticated
    function isAuthenticated() {
      return request.auth != null;
    }

    // Helper: Check if user is part of a couple
    function isPartnerInCouple(coupleId) {
      return isAuthenticated() &&
        request.auth.uid in get(/databases/$(database)/documents/couples/$(coupleId)).data.partnerIds;
    }

    // Helper: Get the other partner's ID
    function getPartnerId(coupleData) {
      return coupleData.partnerIds[0] == request.auth.uid
        ? coupleData.partnerIds[1]
        : coupleData.partnerIds[0];
    }

    // ============================================
    // USERS COLLECTION
    // ============================================
    match /users/{userId} {
      // Users can read their own document
      allow read: if isAuthenticated() && request.auth.uid == userId;

      // Users can create their own document
      allow create: if isAuthenticated()
        && request.auth.uid == userId
        && request.resource.data.keys().hasAll(['displayName', 'initial', 'createdAt'])
        && request.resource.data.displayName is string
        && request.resource.data.initial is string
        && request.resource.data.initial.size() == 1;

      // Users can update their own document (including activeCoupleId)
      allow update: if isAuthenticated() && request.auth.uid == userId;
    }

    // ============================================
    // COUPLES COLLECTION
    // ============================================
    match /couples/{coupleId} {
      // Partners can read their couple
      allow read: if isAuthenticated()
        && request.auth.uid in resource.data.partnerIds;

      // Anyone authenticated can create a couple (as first partner)
      allow create: if isAuthenticated()
        && request.resource.data.partnerIds.size() == 1
        && request.resource.data.partnerIds[0] == request.auth.uid
        && request.resource.data.status == 'pending'
        && request.resource.data.keys().hasAll(['partnerIds', 'status', 'inviteCode', 'collectiveCupLevel', 'pointsPerAcknowledgment', 'createdAt', 'lastActivityAt']);

      // Partners can update couple (for joining, activity updates)
      allow update: if isAuthenticated()
        && (
          // Original partner updating
          request.auth.uid in resource.data.partnerIds
          // OR new partner joining (must be adding themselves)
          || (
            request.resource.data.partnerIds.size() == 2
            && resource.data.partnerIds.size() == 1
            && request.auth.uid in request.resource.data.partnerIds
            && resource.data.partnerIds[0] in request.resource.data.partnerIds
          )
        );

      // ----------------------------------------
      // PLAYERS SUBCOLLECTION
      // ----------------------------------------
      match /players/{playerId} {
        // Partners can read all players in their couple
        allow read: if isPartnerInCouple(coupleId);

        // Users can create their own player document
        allow create: if isAuthenticated()
          && playerId == request.auth.uid
          && request.resource.data.keys().hasAll(['cupLevel', 'gemCount', 'joinedAt'])
          && request.resource.data.cupLevel == 0
          && request.resource.data.gemCount == 0;

        // Partners can update player documents (for gem/cup updates)
        allow update: if isPartnerInCouple(coupleId);
      }

      // ----------------------------------------
      // ATTEMPTS SUBCOLLECTION
      // ----------------------------------------
      match /attempts/{attemptId} {
        // Partners can read all attempts
        allow read: if isPartnerInCouple(coupleId);

        // Partners can create attempts (for their partner, not themselves)
        allow create: if isPartnerInCouple(coupleId)
          && request.resource.data.byPlayerId == request.auth.uid
          && request.resource.data.forPlayerId != request.auth.uid
          && request.resource.data.acknowledged == false
          && request.resource.data.keys().hasAll(['byPlayerId', 'forPlayerId', 'action', 'createdAt', 'acknowledged']);

        // Only recipient can acknowledge (update acknowledged field)
        allow update: if isPartnerInCouple(coupleId)
          && resource.data.forPlayerId == request.auth.uid
          && resource.data.acknowledged == false
          && request.resource.data.acknowledged == true;
      }

      // ----------------------------------------
      // REQUESTS SUBCOLLECTION
      // ----------------------------------------
      match /requests/{requestId} {
        // Partners can read all requests
        allow read: if isPartnerInCouple(coupleId);

        // Partners can create requests
        allow create: if isPartnerInCouple(coupleId)
          && request.resource.data.byPlayerId == request.auth.uid
          && request.resource.data.status == 'active';

        // Partners can update requests (cancel own, mark fulfilled)
        allow update: if isPartnerInCouple(coupleId);
      }

      // ----------------------------------------
      // SUGGESTIONS SUBCOLLECTION
      // ----------------------------------------
      match /suggestions/{suggestionId} {
        allow read: if isPartnerInCouple(coupleId);
        allow create: if isPartnerInCouple(coupleId)
          && request.resource.data.createdByPlayerId == request.auth.uid;
        allow update, delete: if isPartnerInCouple(coupleId);
      }
    }

    // ============================================
    // INVITE CODES COLLECTION
    // ============================================
    match /inviteCodes/{inviteCode} {
      // Anyone authenticated can read (to validate codes)
      allow read: if isAuthenticated();

      // Anyone authenticated can create invite codes
      allow create: if isAuthenticated()
        && request.resource.data.creatorId == request.auth.uid
        && request.resource.data.status == 'active';

      // Anyone authenticated can update (to mark as used when joining)
      allow update: if isAuthenticated()
        && resource.data.status == 'active'
        && request.resource.data.status == 'used';
    }
  }
}
